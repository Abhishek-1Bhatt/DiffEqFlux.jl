<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization of Ordinary Differential Equations · DiffEqFlux.jl</title><link rel="canonical" href="https://diffeqflux.sciml.ai/stable/examples/LV-ODE/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DiffEqFlux.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DiffEqFlux.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Optimization of Ordinary Differential Equations</a></li><li><a class="tocitem" href="../LV-stochastic/">Optimization of Stochastic Differential Equations</a></li><li><a class="tocitem" href="../LV-Flux/">Lotka-Volterra with Flux.train!</a></li><li><a class="tocitem" href="../LV-delay/">Delay Differential Equations</a></li><li><a class="tocitem" href="../NN-ODE/">Neural Ordinary Differential Equations with sciml_train</a></li><li><a class="tocitem" href="../NeuralODE_Flux/">Neural Ordinary Differential Equations with Flux.train!</a></li><li><a class="tocitem" href="../Supervised-NN-ODE-MNIST/">GPU-based MNIST Neural ODE Classifier</a></li><li><a class="tocitem" href="../local_minima/">Strategies to Avoid Local Minima</a></li><li><a class="tocitem" href="../NN-SDE/">Neural Stochastic Differential Equations</a></li><li><a class="tocitem" href="../NeuralOptimalControl/">Solving Optimal Control Problems with Universal Differential Equations</a></li><li><a class="tocitem" href="../LV-Univ/">Universal Differential Equations for Neural Feedback Control</a></li><li><a class="tocitem" href="../SecondOrderNeural/">Neural Second Order Ordinary Differential Equation</a></li><li><a class="tocitem" href="../LV-NN-Stiff/">Enforcing Physical Constraints via Universal Differential-Algebraic Equations</a></li><li><a class="tocitem" href="../NewtonSecondOrderAdjoints/">Newton and Hessian-Free Newton-Krylov with Second Order Adjoint Sensitivity Analysis</a></li><li><a class="tocitem" href="../LV-Jump/">Neural Jump Diffusions (Neural Jump SDE) and Neural Partial Differential Equations (Neural PDEs)</a></li><li><a class="tocitem" href="../universaldiffeq/">Universal Ordinary, Stochastic, and Partial Diffrential Equation Examples</a></li></ul></li><li><a class="tocitem" href="../../NeuralDELayers/">Neural Differential Equation Layers</a></li><li><a class="tocitem" href="../../Flux/">Use with Flux Chain and train!</a></li><li><a class="tocitem" href="../../FastChain/">FastChain</a></li><li><a class="tocitem" href="../../GPUs/">GPUs</a></li><li><a class="tocitem" href="../../Scimltrain/">sciml_train</a></li><li><a class="tocitem" href="../../Benchmark/">Benchmark</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Optimization of Ordinary Differential Equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization of Ordinary Differential Equations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqFlux.jl/blob/master/docs/src/examples/LV-ODE.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimization-of-Ordinary-Differential-Equations-1"><a class="docs-heading-anchor" href="#Optimization-of-Ordinary-Differential-Equations-1">Optimization of Ordinary Differential Equations</a><a class="docs-heading-anchor-permalink" href="#Optimization-of-Ordinary-Differential-Equations-1" title="Permalink"></a></h1><p>First let&#39;s create a Lotka-Volterra ODE using DifferentialEquations.jl. For more details, <a href="http://docs.juliadiffeq.org/dev/">see the DifferentialEquations.jl documentation</a>. The Lotka-Volterra equations have the form:</p><div>\[\begin{aligned}
\frac{dx}{dt} &amp;= \alpha x - \beta x y      \\
\frac{dy}{dt} &amp;= -\delta y + \gamma x y    \\
\end{aligned}\]</div><pre><code class="language-julia">using DifferentialEquations, Flux, Optim, DiffEqFlux, DiffEqSensitivity, Plots

function lotka_volterra!(du, u, p, t)
  x, y = u
  α, β, δ, γ = p
  du[1] = dx = α*x - β*x*y
  du[2] = dy = -δ*y + γ*x*y
end

# Initial condition
u0 = [1.0, 1.0]

# Simulation interval and intermediary points
tspan = (0.0, 10.0)
tsteps = 0.0:0.1:10.0

# LV equation parameter. p = [α, β, δ, γ]
p = [1.5, 1.0, 3.0, 1.0]

# Setup the ODE problem, then solve
prob_ode = ODEProblem(lotka_volterra!, u0, tspan, p)
sol_ode = solve(prob_ode, Tsit5())

# Plot the solution
using Plots
plot(sol_ode)
savefig(&quot;LV_ode.png&quot;)</code></pre><p><img src="https://user-images.githubusercontent.com/1814174/51388169-9a07f300-1af6-11e9-8c6c-83c41e81d11c.png" alt="LV Solution Plot"/></p><p>For this first example, we do not yet include a neural network. We take <a href="https://docs.juliadiffeq.org/latest/analysis/sensitivity/">AD-compatible <code>solve</code> function</a> function that takes the parameters and an initial condition and returns the solution of the differential equation as a <a href="https://github.com/JuliaDiffEq/RecursiveArrayTools.jl"><code>DiffEqArray</code></a> (same array semantics as the standard differential equation solution object but without the interpolations).</p><pre><code class="language-julia"># Create a solution (prediction) for a given starting point u0 and set of
# parameters p
function predict_adjoint(p)
  return Array(solve(prob_ode, Tsit5(), p=p, saveat = tsteps))
end
nothing</code></pre><p>Next we choose a square loss function. Our goal will be to find parameter that make the Lotka-Volterra solution constant <code>x(t)=1</code>, so we defined our loss as the squared distance from 1. Note that when using <code>sciml_train</code>, the first return is the loss value, and the other returns are sent to the callback for monitoring convergence.</p><pre><code class="language-julia">function loss_adjoint(p)
  prediction = predict_adjoint(p)
  loss = sum(abs2, x-1 for x in prediction)
  return loss, prediction
end
nothing</code></pre><p>Lastly, we use the <code>sciml_train</code> function to train the parameters using BFGS to arrive at parameters which optimize for our goal. <code>sciml_train</code> allows defining a callback that will be called at each step of our training loop. It takes in the current parameter vector and the returns of the last call to the loss function. We will display the current loss and make a plot of the current situation:</p><pre><code class="language-julia"># Callback function to observe training
list_plots = []
iter = 0
callback = function (p, l, pred)
  global iter, list_plots

  if iter == 0
    list_plots = []
  end
  iter += 1

  display(l)

  # using `remake` to re-create our `prob` with current parameters `p`
  remade_solution = solve(remake(prob_ode, p = p), Tsit5(), saveat = tsteps)
  plt = plot(remade_solution, ylim = (0, 6))

  push!(list_plots, plt)
  display(plt)

  # Tell sciml_train to not halt the optimization. If return true, then
  # optimization stops.
  return false
end
nothing</code></pre><p>Let&#39;s optimise the model.</p><pre><code class="language-julia">result_ode = DiffEqFlux.sciml_train(loss_adjoint, p,
                                    BFGS(initial_stepnorm = 0.0001),
                                    cb = callback)</code></pre><p>In just seconds we found parameters which give a relative loss of <code>1e-6</code>! We can get the final loss with <code>result_ode.minimum</code>, and get the optimal parameters with <code>result_ode.minimizer</code>. For example, we can plot the final outcome and show that we solved the control problem and successfully found parameters to make the ODE solution constant:</p><pre><code class="language-julia">remade_solution = solve(remake(prob_ode, p = result_ode.minimizer), Tsit5(),      
                        saveat = tsteps)
#plot(remade_solution, ylim = (0, 6))
#savefig(&quot;LV_ode2.png&quot;)</code></pre><p><img src="https://user-images.githubusercontent.com/1814174/51399500-1f4dd080-1b14-11e9-8c9d-144f93b6eac2.gif" alt="Final plot"/></p><p>This shows the evolution of the solutions:</p><pre><code class="language-">animate(list_plots) # hide</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../LV-stochastic/">Optimization of Stochastic Differential Equations »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 2 June 2020 00:48">Tuesday 2 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
